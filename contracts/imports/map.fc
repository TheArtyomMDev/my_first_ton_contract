#include "stdlib.fc";

cell create_node(int key, cell value) {
    return begin_cell()
        .store_uint(key, 32)
        .store_ref(value)
        .store_ref(null())
        .store_ref(null())
        .end_cell();
}

(int, cell) get_key(cell node) {
    slice cs = node.begin_parse();
    return (cs~load_uint(32), cs~load_ref());
}

cell get_left_child(cell node) {
    slice cs = node.begin_parse();
    cs~skip_bits(32);
    cs~load_ref();
    return cs~load_ref();
}

cell get_right_child(cell node) {
    slice cs = node.begin_parse();
    cs~skip_bits(32);
    cs~load_ref();
    cs~load_ref();
    return cs~load_ref();
}

cell set_left_child(cell node, cell left) {
    var (key, value) = get_key(node);
    var right = get_right_child(node);
    return begin_cell()
        .store_uint(key, 32)
        .store_ref(value)
        .store_ref(left)
        .store_ref(right)
        .end_cell();
}

cell set_right_child(cell node, cell right) {
    var (key, value) = get_key(node);
    var left = get_left_child(node);
    return begin_cell()
        .store_uint(key, 32)
        .store_ref(value)
        .store_ref(left)
        .store_ref(right)
        .end_cell();
}

cell BST_insert(cell root, int key, cell value) {
    if (null?(root)) {
        return create_node(key, value);
    }

    var (root_key, root_value) = get_key(root);

    if (key < root_key) {
        var left_child = get_left_child(root);
        var new_left_child = BST_insert(left_child, key, value);
        return set_left_child(root, new_left_child);
    } elseif (key > root_key) {
        var right_child = get_right_child(root);
        var new_right_child = BST_insert(right_child, key, value);
        return set_right_child(root, new_right_child);
    } else {
        return create_node(key, value);
    }
}

(int, cell) BST_find(cell root, int key) {
    if (null?(root)) {
        return (0, null());
    }

    var (root_key, root_value) = get_key(root);

    if (key < root_key) {
        return BST_find(get_left_child(root), key);
    } elseif (key > root_key) {
        return BST_find(get_right_child(root), key);
    } else {
        return (1, root_value);
    }
}